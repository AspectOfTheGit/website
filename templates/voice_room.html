<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect's Site</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/favicon.png') }}">
</head>
<footer class="site-footer">
  <div class="footer-left">
    <a href="https://store.legitimoose.com" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/cart.svg') }}" alt="Store" width="64" height="64">
    </a>
  </div>

  <div class="footer-center">
    <p>
      This is not an official Moose project and is made by the community.<br>
      We have no affiliation with any real-world brands.<br>
      Not affiliated with Mojang AB or Partners.
    </p>
  </div>

  <div class="footer-right">
    <a href="https://www.youtube.com/@Legitimoose" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/youtube.svg') }}" alt="YouTube" width="64" height="64">
    </a>
  </div>
</footer>

<body>
    <nav class="navbar">
        <div class="logo">
            <a href="https://aspectofthe.site/" class="logo">
                <img src="{{ url_for('static', filename='icons/favicon.png') }}" alt="Logo" class="logo-img">
            </a>
            Aspect's Site
        </div>
    </nav>

    <h2>Voice Room</h2>
    <h3>{{ world_uuid }}</h3>
    <p>Audio is not stored anywhere. I don't have enough space to store it anyway.</p>
    <div id="voice-controls" style="margin: 10px 0;">
        <button id="mute-btn">Mute</button>
        <button id="deafen-btn">Deafen</button>
        <label for="mic-select">Mic:</label>
        <select id="mic-select"></select>
    </div>
    
    <div id="user-volumes" style="margin-top: 10px;">
        <h4>User Volumes</h4>
    </div>
</body>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js" crossorigin="anonymous"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {
    const socket = io("https://aspectofthe.site", { transports: ["websocket"] });
    const room = "voice-{{ world_uuid }}";
    socket.emit("join", room);

    /* Variables */

    const peers = {};
    const peerSidToUUID = {};
    const gainNodesByUUID = {};
    const panNodesByUUID = {};
    const volumeControlsByUUID = {};

    let localStream;
    let myPos = [0,0,0];
    let myRot = [0,0]; // yaw, pitch
    const MAX_DISTANCE = 10;

    let isMuted = false;
    let isDeafened = false;

    const audioContext = new AudioContext();

    /* UI */

    const muteBtn = document.getElementById("mute-btn");
    const deafenBtn = document.getElementById("deafen-btn");
    const micSelect = document.getElementById("mic-select");
    const userVolumesDiv = document.getElementById("user-volumes");

    /* Mic stuff */

    async function populateMicrophones(){
        const devices = await navigator.mediaDevices.enumerateDevices();
        micSelect.innerHTML = "";
        devices.filter(d=>d.kind==="audioinput").forEach((d,i)=>{
            const opt = document.createElement("option");
            opt.value = d.deviceId;
            opt.textContent = d.label || `Mic ${i+1}`;
            micSelect.appendChild(opt);
        });
    }

    async function getLocalStream(deviceId=null){
        if(localStream){
            localStream.getTracks().forEach(t=>t.stop());
        }
        localStream = await navigator.mediaDevices.getUserMedia({
            audio: deviceId ? { deviceId } : true
        });
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);

        Object.values(peers).forEach(pc=>{
            const sender = pc.getSenders().find(s=>s.track && s.track.kind==="audio");
            if(sender) sender.replaceTrack(localStream.getAudioTracks()[0]);
        });
    }

    await populateMicrophones();
    await getLocalStream();

    micSelect.addEventListener("change", ()=>getLocalStream(micSelect.value));

    muteBtn.onclick = ()=>{
        isMuted = !isMuted;
        muteBtn.textContent = isMuted ? "Unmute" : "Mute";
        localStream.getAudioTracks().forEach(t=>t.enabled = !isMuted);
    };

    deafenBtn.onclick = ()=>{
        isDeafened = !isDeafened;
        deafenBtn.textContent = isDeafened ? "Undeafen" : "Deafen";
        Object.values(gainNodesByUUID).forEach(g=>g.gain.value = isDeafened ? 0 : g.gain.value);
    };

    /* WebRTC */

    socket.on("existing-peers", async sids=>{
        for(const sid of sids) await createPeerConnection(sid,true);
    });

    socket.on("new-peer", async sid=>{
        if(!peers[sid]) await createPeerConnection(sid,false);
    });

    socket.on("signal", async ({from,signal})=>{
        if(!peers[from]) await createPeerConnection(from,false);
        const pc = peers[from];

        if(signal.type==="offer"){
            await pc.setRemoteDescription(signal);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit("signal",{to:from,signal:pc.localDescription});
        }else if(signal.type==="answer"){
            await pc.setRemoteDescription(signal);
        }else if(signal.candidate){
            try{ await pc.addIceCandidate(signal.candidate);}catch{}
        }
    });

    async function createPeerConnection(peerSid,isInitiator){
        const pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
        peers[peerSid] = pc;

        localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));

        pc.ontrack = (e)=>{
            const source = audioContext.createMediaStreamSource(e.streams[0]);
            const gain = audioContext.createGain();
            const pan = audioContext.createStereoPanner();

            gain.gain.value = 1;
            pan.pan.value = 0;

            source.connect(gain).connect(pan).connect(audioContext.destination);

            const uuid = peerSidToUUID[peerSid];
            if(uuid){
                gainNodesByUUID[uuid] = gain;
                panNodesByUUID[uuid] = pan;
            }
        };

        pc.onicecandidate = e=>{
            if(e.candidate){
                socket.emit("signal",{to:peerSid,signal:{candidate:e.candidate}});
            }
        };

        if(isInitiator){
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit("signal",{to:peerSid,signal:pc.localDescription});
        }
    }

    /* math */

    function distance3D(a,b){
        const dx=a[0]-b[0], dy=a[1]-b[1], dz=a[2]-b[2];
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }

    function computePan(listenerPos, listenerYaw, sourcePos){
        const dx = sourcePos[0] - listenerPos[0];
        const dz = sourcePos[2] - listenerPos[2];

        const angleToSource = Math.atan2(dz, dx);
        const yawRad = (-listenerYaw + 90) * Math.PI / 180;
        const relative = angleToSource - yawRad;

        return clamp(Math.sin(relative), -1, 1);
    }

    /* Volume and Volume control UI */

    function updateVolumes(players){

        players.forEach(p=>{
            if(p.uuid && p.peerSid){
                peerSidToUUID[p.peerSid] = p.uuid;
            }
        });

        players.forEach(player=>{
            if(!Array.isArray(player.Pos)) return;

            if(player.uuid === "{{ mc_uuid }}"){
                myPos = player.Pos;
                myRot = player.Rot || [0,0];
                return;
            }

            const dist = distance3D(myPos, player.Pos);
            const baseVol = clamp(1 - dist / MAX_DISTANCE, 0, 1);

            const gain = gainNodesByUUID[player.uuid];
            const pan = panNodesByUUID[player.uuid];
            if(!gain || !pan) return;

            const userSlider = volumeControlsByUUID[player.uuid] || 1;
            gain.gain.value = isDeafened ? 0 : baseVol * userSlider;

            pan.pan.value = computePan(myPos, myRot[0], player.Pos);

            if(!volumeControlsByUUID[player.uuid]){
                const row = document.createElement("div");
                row.style.display="flex";
                row.style.alignItems="center";
                row.style.gap="8px";
                row.style.marginBottom="6px";

                const img = document.createElement("img");
                img.src = `https://mc-heads.net/avatar/${player.uuid}/32`;
                img.width = 32;

                const name = document.createElement("span");
                name.textContent = player.Name;
                name.style.minWidth="150px";

                const slider = document.createElement("input");
                slider.type="range";
                slider.min=0; slider.max=1; slider.step=0.01; slider.value=1;
                slider.oninput = ()=>gain.gain.value = baseVol * slider.value;

                row.append(img,name,slider);
                userVolumesDiv.appendChild(row);

                volumeControlsByUUID[player.uuid] = slider;
            }
        });
    }

    socket.on("update", players => updateVolumes(players));

});
</script>
