<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect's Site</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/favicon.png') }}">
</head>
<footer class="site-footer">
  <div class="footer-left">
    <a href="https://store.legitimoose.com" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/cart.svg') }}" alt="Store" width="64" height="64">
    </a>
  </div>

  <div class="footer-center">
    <p>
      This is not an official Moose project and is made by the community.<br>
      We have no affiliation with any real-world brands.<br>
      Not affiliated with Mojang AB or Partners.
    </p>
  </div>

  <div class="footer-right">
    <a href="https://www.youtube.com/@Legitimoose" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/youtube.svg') }}" alt="YouTube" width="64" height="64">
    </a>
  </div>
</footer>

<body>
    <nav class="navbar">
        <div class="logo">
            <a href="https://aspectofthe.site/" class="logo">
                <img src="{{ url_for('static', filename='icons/favicon.png') }}" alt="Logo" class="logo-img">
            </a>
            Aspect's Site
        </div>
    </nav>

    <h2>Voice Room</h2>
    <h3>{{ world_uuid }}</h3>
    <p>Audio is not stored anywhere. I don't have enough space to store it anyway.</p>
    <div id="voice-controls" style="margin: 10px 0;">
        <button id="mute-btn">Mute</button>
        <button id="deafen-btn">Deafen</button>
        <label for="mic-select">Mic:</label>
        <select id="mic-select"></select>
    </div>
    
    <div id="user-volumes" style="margin-top: 10px;">
        <h4>User Volumes</h4>
    </div>
</body>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js" crossorigin="anonymous"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {
    const socket = io("https://aspectofthe.site", { transports: ["websocket"] });
    const room = "voice-{{ world_uuid }}";

    const peers = {};
    const gainNodesByUUID = {};
    const panNodesByUUID = {};
    const volumeControlsByUUID = {};
    const pendingAudioNodes = [];

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    let localStream;
    let myPos = [0, 0, 0];
    let myRot = [0, 0];
    const MAX_DISTANCE = 10;

    let isMuted = false;
    let isDeafened = false;

    const muteBtn = document.getElementById("mute-btn");
    const deafenBtn = document.getElementById("deafen-btn");
    const micSelect = document.getElementById("mic-select");
    const userVolumesDiv = document.getElementById("user-volumes");

    /* Mic stuff */

    async function populateMicrophones() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        micSelect.innerHTML = "";
        devices.filter(d => d.kind === "audioinput").forEach(d => {
            const opt = document.createElement("option");
            opt.value = d.deviceId;
            opt.textContent = d.label || "Microphone";
            micSelect.appendChild(opt);
        });
    }

    async function getLocalStream(deviceId=null) {
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        localStream = await navigator.mediaDevices.getUserMedia({
            audio: deviceId ? { deviceId } : true
        });
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);

        Object.values(peers).forEach(pc => {
            const sender = pc.getSenders().find(s => s.track?.kind === "audio");
            if (sender) sender.replaceTrack(localStream.getAudioTracks()[0]);
        });
    }

    await populateMicrophones();
    await getLocalStream();

    micSelect.onchange = () => getLocalStream(micSelect.value);

    muteBtn.onclick = () => {
        isMuted = !isMuted;
        muteBtn.textContent = isMuted ? "Unmute" : "Mute";
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
    };

    deafenBtn.onclick = () => {
        isDeafened = !isDeafened;
        deafenBtn.textContent = isDeafened ? "Undeafen" : "Deafen";
    };

    /* WebRTC */

    socket.emit("join", room);

    socket.on("existing-peers", peers =>
        peers.forEach(sid => createPeerConnection(sid, true))
    );

    socket.on("signal", async ({ from, signal }) => {
        if (!peers[from]) await createPeerConnection(from, false);
        const pc = peers[from];

        if (signal.type === "offer") {
            await pc.setRemoteDescription(signal);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit("signal", { to: from, signal: pc.localDescription });
        } else if (signal.type === "answer") {
            await pc.setRemoteDescription(signal);
        } else if (signal.candidate) {
            try { await pc.addIceCandidate(signal.candidate); } catch {}
        }
    });

    async function createPeerConnection(peerSid, initiator) {
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });

        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

        pc.ontrack = (e) => {
            const source = audioContext.createMediaStreamSource(e.streams[0]);
            const gain = audioContext.createGain();
            const pan = audioContext.createStereoPanner();

            gain.gain.value = 1;
            pan.pan.value = 0;

            source.connect(gain).connect(pan).connect(audioContext.destination);
            pendingAudioNodes.push({ gain, pan });
        };

        pc.onicecandidate = e => {
            if (e.candidate)
                socket.emit("signal", { to: peerSid, signal: { candidate: e.candidate } });
        };

        peers[peerSid] = pc;

        if (initiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit("signal", { to: peerSid, signal: pc.localDescription });
        }
    }

    /* math */

    function distance(a, b) {
        const dx = a[0]-b[0], dz = a[2]-b[2];
        return Math.sqrt(dx*dx + dz*dz);
    }

    function computePan(listenerPos, listenerYaw, sourcePos) {
        const dx = sourcePos[0] - listenerPos[0];
        const dz = sourcePos[2] - listenerPos[2];

        const angleToSource = Math.atan2(-dx, dz) * 180 / Math.PI;
        let delta = angleToSource - listenerYaw;

        delta = ((delta + 180) % 360) - 180;
        return Math.max(-1, Math.min(1, delta / 90));
    }

    /* Volume and volume control UI */

    function updateVolumes(players) {
        players.forEach(player => {
            if (!Array.isArray(player.Pos)) return;

            if (player.uuid === "{{ mc_uuid }}") {
                myPos = player.Pos;
                if (Array.isArray(player.Rot)) myRot = player.Rot;
                return;
            }

            if (!gainNodesByUUID[player.uuid] && pendingAudioNodes.length) {
                const node = pendingAudioNodes.shift();
                gainNodesByUUID[player.uuid] = node.gain;
                panNodesByUUID[player.uuid] = node.pan;
            }

            const gain = gainNodesByUUID[player.uuid];
            const pan = panNodesByUUID[player.uuid];
            if (!gain || !pan) return;

            const dist = distance(myPos, player.Pos);
            const baseVol = Math.max(0, 1 - dist / MAX_DISTANCE);
            const userVol = volumeControlsByUUID[player.uuid]?.value ?? 1;
            const finalVol = isDeafened ? 0 : baseVol * userVol;

            gain.gain.setTargetAtTime(finalVol, audioContext.currentTime, 0.05);
            pan.pan.setTargetAtTime(
                computePan(myPos, myRot[0], player.Pos),
                audioContext.currentTime,
                0.05
            );

            if (!volumeControlsByUUID[player.uuid]) {
                const row = document.createElement("div");
                row.style.display = "flex";
                row.style.alignItems = "center";
                row.style.gap = "8px";

                const head = document.createElement("img");
                head.src = `https://mc-heads.net/avatar/${player.uuid}/32`;

                const name = document.createElement("span");
                name.textContent = player.Name;
                name.style.minWidth = "200px";
                name.style.fontFamily = "monospace";

                const slider = document.createElement("input");
                slider.type = "range";
                slider.min = 0;
                slider.max = 1;
                slider.step = 0.01;
                slider.value = 1;

                row.append(head, name, slider);
                userVolumesDiv.appendChild(row);
                volumeControlsByUUID[player.uuid] = slider;
            }
        });
    }

    socket.on("update", updateVolumes);
});
</script>
