<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voice Room</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
</head>

<body>
<h2>Voice Room</h2>
<div id="voice-controls">
    <button id="mute-btn">Mute</button>
    <button id="deafen-btn">Deafen</button>
    <select id="mic-select"></select>
</div>

<div id="user-volumes">
    <h4>Connected Users</h4>
</div>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {

    const socket = io("https://aspectofthe.site", { transports: ["websocket"] });
    socket.emit("join", "voice-{{ world_uuid }}");
    

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    document.body.addEventListener("click", () => {
        if (audioCtx.state !== "running") audioCtx.resume();
    }, { once: true });

    const gainNodesByUUID = {};
    const audioSourcesByUUID = {};

    /* variables */

    const peers = {};
    const volumeControlsByUUID = {};
    const targetPositions = {};
    const smoothedPositions = {};

    let myPos = [0,0,0];
    let localStream;
    let isMuted = false;
    let isDeafened = false;

    const MAX_DISTANCE = 25;
    const FALL_OFF = 0.18;
    const POSITION_LERP = 0.15;

    const muteBtn = document.getElementById("mute-btn");
    const deafenBtn = document.getElementById("deafen-btn");
    const micSelect = document.getElementById("mic-select");
    const userVolumesDiv = document.getElementById("user-volumes");

    /* mic */

    async function populateMicrophones() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        micSelect.innerHTML = "";
        devices.filter(d => d.kind === "audioinput").forEach((d,i)=>{
            const o = document.createElement("option");
            o.value = d.deviceId;
            o.textContent = d.label || `Mic ${i+1}`;
            micSelect.appendChild(o);
        });
    }

    async function getLocalStream(deviceId=null){
        if(localStream) localStream.getTracks().forEach(t=>t.stop());

        localStream = await navigator.mediaDevices.getUserMedia({
            audio: deviceId ? { deviceId } : true
        });

        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);

        Object.values(peers).forEach(pc=>{
            const sender = pc.getSenders().find(s=>s.track?.kind==="audio");
            if(sender) sender.replaceTrack(localStream.getAudioTracks()[0]);
        });
    }

    await populateMicrophones();
    await getLocalStream();
    micSelect.onchange = () => getLocalStream(micSelect.value);

    muteBtn.onclick = () => {
        isMuted = !isMuted;
        muteBtn.textContent = isMuted ? "Unmute" : "Mute";
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
    };

    deafenBtn.onclick = () => {
        isDeafened = !isDeafened;
        deafenBtn.textContent = isDeafened ? "Undeafen" : "Deafen";
    };

    /* WebRTC */

    socket.on("existing-peers", async sids=>{
        for(const sid of sids) await createPeerConnection(sid, true);
    });

    socket.on("new-peer", async sid=>{
        if(!peers[sid]) await createPeerConnection(sid, false);
    });

    socket.on("signal", async ({from, signal})=>{
        if(!peers[from]) await createPeerConnection(from, false);
        const pc = peers[from];

        if(signal.type==="offer"){
            await pc.setRemoteDescription(signal);
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            socket.emit("signal",{to:from,signal:pc.localDescription});
        }else if(signal.type==="answer"){
            await pc.setRemoteDescription(signal);
        }else if(signal.candidate){
            try{ await pc.addIceCandidate(signal.candidate); }catch{}
        }
    });

    async function createPeerConnection(peerSid,isInitiator){
        const pc = new RTCPeerConnection({
            iceServers:[{urls:"stun:stun.l.google.com:19302"}]
        });

        peers[peerSid] = pc;
        localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));

        pc.ontrack = (e)=>{
            const stream = e.streams[0];

            const source = audioCtx.createMediaStreamSource(stream);
            const gain = audioCtx.createGain();
            gain.gain.value = 1;

            source.connect(gain).connect(audioCtx.destination);

            audioSourcesByUUID[peerSid] = source;
            gainNodesByUUID[peerSid] = gain;

            console.log("ðŸŽ§ Audio bound to peer", peerSid);
        };

        pc.onicecandidate = e=>{
            if(e.candidate){
                socket.emit("signal",{to:peerSid,signal:{candidate:e.candidate}});
            }
        };

        if(isInitiator){
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit("signal",{to:peerSid,signal:pc.localDescription});
        }
    }

    /* audio */

    function distance3D(a,b){
        const dx=a[0]-b[0], dy=a[1]-b[1], dz=a[2]-b[2];
        return Math.sqrt(dx*dx+dy*dy+dz*dz);
    }

    function lerp(a,b,t){ return a+(b-a)*t; }
    function lerpVec(a,b,t){
        return [lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)];
    }

    function expFalloff(dist){
        if(dist>=MAX_DISTANCE) return 0;
        return Math.exp(-FALL_OFF*dist);
    }

    socket.on("update", players=>{
        console.group("VOICE UPDATE");
        players.forEach(p=>{
            if(!Array.isArray(p.Pos)) return;

            if(p.uuid === "{{ mc_uuid }}"){
                myPos = p.Pos;
                return;
            }

            targetPositions[p.uuid] = p.Pos;
            if(!smoothedPositions[p.uuid])
                smoothedPositions[p.uuid] = [...p.Pos];

            if(!volumeControlsByUUID[p.uuid]){
                const row = document.createElement("div");
                row.style.display="flex";
                row.style.gap="8px";

                const img=document.createElement("img");
                img.src=`https://mc-heads.net/head/${p.uuid}/left`;
                img.width=32;

                const label=document.createElement("span");
                label.textContent=p.Name||p.uuid;
                label.style.width="160px";

                const slider=document.createElement("input");
                slider.type="range"; slider.min=0; slider.max=1;
                slider.step=0.01; slider.value=1;

                volumeControlsByUUID[p.uuid]=slider;
                row.append(img,label,slider);
                userVolumesDiv.appendChild(row);
            }
        });
        console.groupEnd();
    });

    function audioLoop(){
        for(const uuid in gainNodesByUUID){
            const target = targetPositions[uuid];
            const gain = gainNodesByUUID[uuid];
            const slider = volumeControlsByUUID[uuid];
            if(!target||!gain||!slider) continue;

            smoothedPositions[uuid]=lerpVec(smoothedPositions[uuid],target,POSITION_LERP);
            const dist=distance3D(myPos,smoothedPositions[uuid]);
            const base=expFalloff(dist);
            const final=isDeafened?0:base*parseFloat(slider.value);

            gain.gain.value = final;

            console.debug("VOL APPLY",{uuid,dist,base,final});
        }
        requestAnimationFrame(audioLoop);
    }

    audioLoop();
});
</script>
</body>
</html>
