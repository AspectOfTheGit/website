<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect's Site</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/favicon.png') }}">
</head>
<footer class="site-footer">
  <div class="footer-left">
    <a href="https://store.legitimoose.com" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/cart.svg') }}" alt="Store" width="64" height="64">
    </a>
  </div>

  <div class="footer-center">
    <p>
      This is not an official Moose project and is made by the community.<br>
      We have no affiliation with any real-world brands.<br>
      Not affiliated with Mojang AB or Partners.
    </p>
  </div>

  <div class="footer-right">
    <a href="https://www.youtube.com/@Legitimoose" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/youtube.svg') }}" alt="YouTube" width="64" height="64">
    </a>
  </div>
</footer>

<body>
    <nav class="navbar">
        <div class="logo">
            <a href="https://aspectofthe.site/" class="logo">
                <img src="{{ url_for('static', filename='icons/favicon.png') }}" alt="Logo" class="logo-img">
            </a>
            Aspect's Site
        </div>
    </nav>

    <h2>Voice Room</h2>
    <h3>{{ world_uuid }}</h3>
    <p>Audio is not stored anywhere. I don't have enough space to store it anyway.</p>
    <div id="voice-controls" style="margin: 10px 0;">
        <button id="mute-btn">Mute</button>
        <button id="deafen-btn">Deafen</button>
        <label for="mic-select">Mic:</label>
        <select id="mic-select"></select>
    </div>
    
    <div id="user-volumes" style="margin-top: 10px;">
        <h4>User Volumes</h4>
    </div>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {

    const socket = io("https://aspectofthe.site", { transports: ["websocket"] });
    socket.emit("join", "voice-{{ world_uuid }}");
    

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    document.body.addEventListener("click", () => {
        if (audioCtx.state !== "running") audioCtx.resume();
    }, { once: true });

    const gainNodesByUUID = {};
    const peers = {};
    const volumeControlsByUUID = {};


    const targetPositions = {};
    const smoothedPositions = {};
    let myPos = [0, 0, 0];


    let localStream;
    let isMuted = false;
    let isDeafened = false;

    const MAX_DISTANCE = 25;
    const FALL_OFF = 0.18;
    const POSITION_LERP = 0.15;


    const muteBtn = document.getElementById("mute-btn");
    const deafenBtn = document.getElementById("deafen-btn");
    const micSelect = document.getElementById("mic-select");
    const userVolumesDiv = document.getElementById("user-volumes");


    async function populateMicrophones() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        micSelect.innerHTML = "";
        devices.filter(d => d.kind === "audioinput").forEach((d, i) => {
            const o = document.createElement("option");
            o.value = d.deviceId;
            o.textContent = d.label || `Mic ${i + 1}`;
            micSelect.appendChild(o);
        });
    }

    async function getLocalStream(deviceId = null) {
        if (localStream) localStream.getTracks().forEach(t => t.stop());

        localStream = await navigator.mediaDevices.getUserMedia({
            audio: deviceId ? { deviceId } : true
        });

        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);

        Object.values(peers).forEach(pc => {
            const sender = pc.getSenders().find(s => s.track?.kind === "audio");
            if (sender) sender.replaceTrack(localStream.getAudioTracks()[0]);
        });
    }

    await populateMicrophones();
    await getLocalStream();
    micSelect.onchange = () => getLocalStream(micSelect.value);

    muteBtn.onclick = () => {
        isMuted = !isMuted;
        muteBtn.textContent = isMuted ? "Unmute" : "Mute";
        localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
    };

    deafenBtn.onclick = () => {
        isDeafened = !isDeafened;
        deafenBtn.textContent = isDeafened ? "Undeafen" : "Deafen";
    };
    

    socket.on("existing-peers", async sids => {
        for (const sid of sids) await createPeerConnection(sid, true);
    });

    socket.on("new-peer", async sid => {
        if (!peers[sid]) await createPeerConnection(sid, false);
    });

    socket.on("signal", async ({ from, signal }) => {
        if (!peers[from]) await createPeerConnection(from, false);
        const pc = peers[from];

        if (signal.type === "offer") {
            await pc.setRemoteDescription(signal);
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            socket.emit("signal", { to: from, signal: pc.localDescription });
        } else if (signal.type === "answer") {
            await pc.setRemoteDescription(signal);
        } else if (signal.candidate) {
            try { await pc.addIceCandidate(signal.candidate); } catch {}
        }
    });

    async function createPeerConnection(peerSid, isInitiator) {
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });

        peers[peerSid] = pc;
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

        pc.ontrack = e => {
            const stream = e.streams[0];
            const source = audioCtx.createMediaStreamSource(stream);
            const gain = audioCtx.createGain();

            gain.gain.value = 1;
            source.connect(gain).connect(audioCtx.destination);
            gainNodesByUUID[peerSid] = gain;

            console.log("ðŸŽ§ Audio bound", peerSid);
        };

        pc.onicecandidate = e => {
            if (e.candidate) {
                socket.emit("signal", { to: peerSid, signal: { candidate: e.candidate } });
            }
        };

        if (isInitiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit("signal", { to: peerSid, signal: pc.localDescription });
        }
    }

    function distance3D(a, b) {
        const dx = a[0] - b[0], dy = a[1] - b[1], dz = a[2] - b[2];
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpVec(a, b, t) {
        return [lerp(a[0], b[0], t), lerp(a[1], b[1], t), lerp(a[2], b[2], t)];
    }

    function expFalloff(dist) {
        if (dist >= MAX_DISTANCE) return 0;
        return Math.exp(-FALL_OFF * dist);
    }

    socket.on("update", players => {
        console.group("VOICE UPDATE");
        console.log(players);

        if (!Array.isArray(players)) {
            console.warn("Update payload is not array");
            console.groupEnd();
            return;
        }

        players.forEach(p => {
            if (!Array.isArray(p.Pos)) return;

            if (p.uuid === "{{ mc_uuid }}") {
                myPos = p.Pos;
                return;
            }

            targetPositions[p.uuid] = p.Pos;
            if (!smoothedPositions[p.uuid])
                smoothedPositions[p.uuid] = [...p.Pos];

            if (!volumeControlsByUUID[p.uuid]) {
                const row = document.createElement("div");
                row.style.display = "flex";
                row.style.gap = "8px";

                const img = document.createElement("img");
                img.src = `https://mc-heads.net/head/${p.uuid}/left`;
                img.width = 32;

                const label = document.createElement("span");
                label.textContent = p.Name || p.uuid;
                label.style.width = "160px";

                const slider = document.createElement("input");
                slider.type = "range";
                slider.min = 0;
                slider.max = 1;
                slider.step = 0.01;
                slider.value = 1;

                volumeControlsByUUID[p.uuid] = slider;
                row.append(img, label, slider);
                userVolumesDiv.appendChild(row);
            }
        });

        console.groupEnd();
    });

    function audioLoop() {
        for (const uuid in gainNodesByUUID) {
            const gain = gainNodesByUUID[uuid];
            const target = targetPositions[uuid];
            const slider = volumeControlsByUUID[uuid];
            if (!gain || !target || !slider) continue;

            smoothedPositions[uuid] =
                lerpVec(smoothedPositions[uuid], target, POSITION_LERP);

            const dist = distance3D(myPos, smoothedPositions[uuid]);
            const base = expFalloff(dist);
            const final = isDeafened ? 0 : base * parseFloat(slider.value);

            gain.gain.value = final;

            console.debug("VOL APPLY", {
                uuid,
                dist: dist.toFixed(2),
                base: base.toFixed(3),
                final: final.toFixed(3)
            });
        }

        requestAnimationFrame(audioLoop);
    }

    audioLoop();
});
</script>
</script>
</body>
</html>
