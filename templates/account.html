<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect's Site</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='icons/favicon.png') }}">
</head>
<footer class="site-footer">
  <div class="footer-left">
    <a href="https://store.legitimoose.com" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/cart.svg') }}" alt="Store" width="64" height="64">
    </a>
  </div>

  <div class="footer-center">
    <p>
      This is not an official Moose project and is made by the community.<br>
      We have no affiliation with any real-world brands.<br>
      Not affiliated with Mojang AB or Partners.
    </p>
  </div>

  <div class="footer-right">
    <a href="https://www.youtube.com/@Legitimoose" target="_blank" rel="noopener noreferrer">
        <img src="{{ url_for('static', filename='icons/youtube.svg') }}" alt="YouTube" width="64" height="64">
    </a>
  </div>
</footer>

<body>
    <nav class="navbar">
        <div class="logo">
            <a href="https://aspectofthe.site/" class="logo">
                <img src="{{ url_for('static', filename='icons/favicon.png') }}" alt="Logo" class="logo-img">
            </a>
            Aspect's Site
        </div>
        <div class="nav-links">
            <a href="/">Home</a>
            <a href="/bots">Bots</a>
            <a href="/utils">Utilities</a>
        </div>
        <div class="login">
            {% if username %}
                <span>{{ username }}</span>
            {% else %}
                <a href="/">Not logged in??</a>
            {% endif %}
        </div>
    </nav>

  <div class="layout">
    <aside class="sidebar">
      <div class="sidebar-top">
        <button class="sidebar-btn active" data-tab="account-status">Account Status</button>
        <button class="sidebar-btn" data-tab="notifs">Notifications</button>
        <button class="sidebar-btn" data-tab="user-storage">User Storage</button>
        <button class="sidebar-btn" data-tab="world-pages">World Pages</button>
        <button class="sidebar-btn logout-btn" id="logout-btn" style="margin-top: 20px;">Logout</button>
      </div>
    </aside>

    <main class="main-content">
      <div id="account-status" class="tab-content active">
        <p class="plaintext">
            Please contact me if you need more capabilities
        </p>
        <table class="account-table">
            <tbody>
                <tr data-tip="How many times you can deploy a bot each day">
                    <td>Uses per day</td>
                    <td class="plaintext">{{ account.used if account.used is defined else 0 }}/{{ account.abilities.uses if account.abilities.uses is defined else 10 }}</td>
                </tr>
                <tr data-tip="How many bots you can have at the same time">
                    <td>Simultaneous Bots</td>
                    <td class="plaintext">{{ account.abilities.simultaneous if account.abilities.simultaneous is defined else 1 }}</td>
                </tr>
                <tr data-tip="How long until your bot will go offline after deploying">
                    <td>Bot uptime limit</td>
                    <td class="plaintext">{{ account.abilities.uptime if account.abilities.uptime is defined else 30 }} mins</td>
                </tr>
                <tr data-tip="Whether your bot will go offline 2 minutes after being alone or not">
                    <td>No abandoned timeout</td>
                    <td class="status {{ 'available' if account.abilities.abandoned is defined else 'unavailable' }}">
                        {{ '✔️' if account.abilities.abandoned is defined else '❌' }}
                    </td>
                </tr>
                <tr data-tip="Whether you can deploy a bot on a world you dont own">
                    <td>Deploy on unowned servers</td>
                    <td class="status {{ 'unavailable' if account.abilities.unowned is defined else 'available' }}">
                        {{ '❌' if account.abilities.unowned is defined else '✔️' }}
                    </td>
                </tr>
                <tr data-tip="Capacity of your user storage">
                    <td>Storage Capacity</td>
                    <td class="plaintext">{{ account.storage.size if account.storage.size is defined else 0 }}B/{{ account.abilities.capacity if account.abilities.capacity is defined else 1 }}MB</td>
                </tr>
                <tr data-tip="Whether you can send a message as a bot">
                    <td>Send Messages</td>
                    <td class="status {{ 'available' if account.abilities.send is defined else 'unavailable' }}">
                        {{ '✔️' if account.abilities.send is defined else '❌' }}
                    </td>
                </tr>
            </tbody>
        </table>
      </div>
      <div id="notifs" class="tab-content">
          <h2>Notifications</h2>
          <p>Send updates on discord (WIP)</p>
      </div>
      <div id="user-storage" class="tab-content">
          <h2>Your Storage</h2>
          <div class="storage-container">
              <h3>Edit Storage</h3>
              <textarea id="storage-textarea">{{ account.storage.contents if account.storage.contents is defined }}</textarea>
              <button id="save-storage-btn">Save</button>
              <span id="storage-status" style="margin-left:10px;"></span>
          </div>
    
          <div class="logs-container">
              <h3>Logs</h3>
              <div id="logs-output" class="log-box"></div>
          </div>
    
          <div class="tokens-container">
              <div class="token-spoiler">
                  <button class="toggle-token-btn">Show Read Token</button>
                  <div class="token-content">
                      <code id="read-token">{{ account.token.read if account.token is defined and account.token.read is defined else "No Token" }}</code>
                      <button class="refresh-token-btn" data-token="read">Refresh</button>
                  </div>
              </div>
    
              <div class="token-spoiler">
                  <button class="toggle-token-btn">Show Write Token</button>
                  <div class="token-content">
                      <code id="write-token">{{ account.token.write if account.token is defined and account.token.write is defined else "No Token" }}</code>
                      <button class="refresh-token-btn" data-token="write">Refresh</button>
                  </div>
              </div>
          </div>

          <h2>How to Use</h3>
          <p class="plaintext">
              Example http request to write:<br>
              <code>
                  /http headers value {"Content-Type":"application/json"} body value "{\"account\":\"&lt;USERNAME>\",\"token\":\"&lt;YOUR_WRITE_TOKEN>\",\"contents\":\"Hello World!\"}" send "https://aspectofthe.site/api/storage/write" POST
              </code>
              <br><br>
              Example http request to read:<br>
              <code>
                  /http store &lt;STORAGE> &lt;PATH> headers value {"Content-Type":"application/json"} body value "{\"account\":\"&lt;USERNAME>\",\"token\":\"&lt;YOUR_READ_TOKEN>\"}" send "https://aspectofthe.site/api/storage/read" POST
              </code>
          </p>
      </div>
      <div id="world-pages" class="tab-content">
        <h2>Your Worlds</h2>
        <div class="dropdown-wrapper">
            <div class="dropdown-wrapper">
                <label class="headerlabel">Choose a world:</label>
            
                <div id="world-dropdown" class="custom-dropdown">
                    <div id="world-selected" class="dropdown-selected">
                        Loading…
                    </div>
                    <div id="world-options" class="dropdown-options"></div>
                </div>
            </div>
        </div>
      </div>
    </main>
  </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js" crossorigin="anonymous"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const accountName = "{{ username }}"
        const socket = io("https://aspectofthe.site", { transports: ["websocket"] });
        const logContainer = document.getElementById("logs-output");

        let ownedworlds = [];

        // socket.io
        socket.emit('join', accountName);
    
        socket.on("log", (contents) => {
            const time = contents[0];
            const msg = contents[1];
            logContainer.textContent += `[${time}] ${msg}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        });
        
        // Sidebar buttons
        const buttons = document.querySelectorAll('.sidebar-btn:not(.logout-btn)');
        const contents = document.querySelectorAll('.tab-content');
    
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));
    
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });
    
        // Logout
        const logoutBtn = document.getElementById('logout-btn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', () => {
                window.location.href = "/logout";
            });
        }
    
        // Save storage
        const saveBtn = document.getElementById('save-storage-btn');
        const textarea = document.getElementById('storage-textarea');
        const status = document.getElementById('storage-status');
    
        if (saveBtn && textarea && status) {
            saveBtn.addEventListener('click', async () => {
                const newContent = textarea.value;
                const writeToken = document.getElementById('write-token')?.textContent || "";
                status.textContent = "Saving...";
    
                try {
                    const res = await fetch('/api/storage/write', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: newContent,
                            account: accountName,
                            token: writeToken
                        })
                    });
    
                    if(res.ok) {
                        status.textContent = "Saved ✅";
                        setTimeout(() => status.textContent = "", 2000);
                    } else {
                        const data = await res.json().catch(() => ({}));
                        if (data.error === "No Token Generated") {
                            status.textContent = "Generate a token first ❌";
                        } else if (data.error === "Storage Limit Exceeded") {
                            status.textContent = "Storage limit exceeded ❌";
                        } else {
                            status.textContent = "Error ❌";
                        }
                    }
                } catch (e) {
                    status.textContent = "Error ❌";
                    console.error(e);
                }
            });
        }
    
        // Spoiler toggles
        document.querySelectorAll('.toggle-token-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const content = btn.nextElementSibling;
                content.style.display = content.style.display === 'flex' ? 'none' : 'flex';
            });
        });
    
        // Refresh tokens
        document.querySelectorAll('.refresh-token-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const type = btn.dataset.token;
                btn.disabled = true;
    
                try {
                    const res = await fetch(`/api/refresh-token/${type}`, { method: 'POST' });
                    if(res.ok) {
                        const data = await res.json();
                        document.getElementById(`${type}-token`).textContent = data.token;
                    }
                } catch (e) {
                    console.error(e);
                } finally {
                    btn.disabled = false;
                }
            });
        });

        function formatUUID(u) {
            u = u.replace(/-/g, "").trim();
            return (
                u.slice(0, 8) + "-" +
                u.slice(8, 12) + "-" +
                u.slice(12, 16) + "-" +
                u.slice(16, 20) + "-" +
                u.slice(20)
            );
        }

        const COLOURS = {
            black: "#000000",
            dark_blue: "#0000AA",
            dark_green: "#00AA00",
            dark_aqua: "#00AAAA",
            dark_red: "#AA0000",
            dark_purple: "#AA00AA",
            gold: "#FFAA00",
            gray: "#AAAAAA",
            dark_gray: "#555555",
            blue: "#5555FF",
            green: "#55FF55",
            aqua: "#55FFFF",
            red: "#FF5555",
            light_purple: "#FF55FF",
            yellow: "#FFFF55",
            white: "#FFFFFF"
        };
        
        const HEX_COLOUR = /^#?[0-9a-fA-F]{6}$/;
        
        function escapeHtml(text) {
            const div = document.createElement("div");
            div.textContent = text;
            return div.innerHTML;
        }
        
        function rawToHtml(component) {
            if (typeof component === "string") {
                try {
                    component = JSON.parse(component);
                } catch {
                    return escapeHtml(component);
                }
            }
        
            const segments = [];
        
            function collect(c, inherited = null) {
                if (typeof c === "string") {
                    const styleStr = inherited?._style_str || "";
                    segments.push([c, styleStr]);
                    return;
                }
        
                if (!inherited) inherited = {};
        
                const text = c.text || "";
                const color = c.color ?? inherited.color;
                const italic = c.italic ?? inherited.italic ?? false;
                const bold = c.bold ?? inherited.bold ?? false;
                const underlined = c.underlined ?? inherited.underlined ?? false;
                const strikethrough = c.strikethrough ?? inherited.strikethrough ?? false;
        
                let resolvedColor = null;
                if (color) {
                    if (COLOURS[color]) {
                        resolvedColor = COLOURS[color];
                    } else if (HEX_COLOUR.test(color)) {
                        resolvedColor = color.startsWith("#") ? color : `#${color}`;
                    }
                }
        
                const styleParts = [];
                if (resolvedColor) styleParts.push(`color:${resolvedColor}`);
                if (italic) styleParts.push("font-style:italic");
                if (bold) styleParts.push("font-weight:bold");
        
                const decorations = [];
                if (underlined) decorations.push("underline");
                if (strikethrough) decorations.push("line-through");
                if (decorations.length) {
                    styleParts.push(`text-decoration:${decorations.join(" ")}`);
                }
        
                const styleStr = styleParts.join(";");
        
                const newInherited = {
                    color: resolvedColor || color,
                    italic,
                    bold,
                    underlined,
                    strikethrough,
                    _style_str: styleStr
                };
        
                if (text) {
                    segments.push([text, styleStr]);
                }
        
                for (const e of c.extra || []) {
                    collect(e, newInherited);
                }
            }
        
            collect(component);
        
            if (!segments.length) return "";
        
            const merged = [];
            let [curText, curStyle] = segments[0];
        
            for (let i = 1; i < segments.length; i++) {
                const [t, s] = segments[i];
                if (s === curStyle) {
                    curText += t;
                } else {
                    merged.push([curText, curStyle]);
                    curText = t;
                    curStyle = s;
                }
            }
            merged.push([curText, curStyle]);
        
            return merged.map(([text, style]) => {
                const escaped = escapeHtml(text);
                if (style) {
                    return `<span style="${style}">${escaped}</span>`;
                }
                return escaped;
            }).join("");
        }

        // Get owned worlds
        async function loadWorlds() {
            loadingWorlds = true;
        
            try {
                const formatted = formatUUID("{{ profile_uuid }}");
                const res = await fetch(`https://api.legiti.dev/owner/${formatted}`);
                ownedworlds = await res.json();
                populateWorldDropdown();
            } catch (err) {
                console.error("Failed to fetch owned worlds:", err);
            }
        
            loadingWorlds = false;
        }
        
        function populateWorldDropdown() {
            const selected = document.getElementById("world-selected");
            const options = document.getElementById("world-options");
        
            options.innerHTML = "";
        
            if (!Array.isArray(ownedworlds) || !ownedworlds.length) {
                selected.textContent = "No worlds found";
                return;
            }
        
            ownedworlds.forEach((world, index) => {
                const opt = document.createElement("div");
                opt.className = "dropdown-option";
                opt.dataset.value = world.world_uuid;
        
                if (world.raw_name) {
                    opt.innerHTML = rawToHtml(world.raw_name);
                } else {
                    opt.textContent = world.name ?? "Unnamed world";
                }
        
                opt.addEventListener("click", () => {
                    selected.innerHTML = opt.innerHTML;
                    options.style.display = "none";
                    window.location.href = `/world/${world.world_uuid}/edit`;
                });
        
                options.appendChild(opt);
            });
        
            selected.innerHTML = "Select a world";
            selected.dataset.value = "";
        }

        // Custom dropdown logic
        const dropdown = document.getElementById("world-dropdown");
        const selected = document.getElementById("world-selected");
        const options = document.getElementById("world-options");
        
        selected.addEventListener("click", () => {
            options.style.display =
                options.style.display === "block" ? "none" : "block";
        });
        
        document.addEventListener("click", e => {
            if (!dropdown.contains(e.target)) {
                options.style.display = "none";
            }
        });

        loadWorlds();
    });
    </script>
  
</body>
</html>
